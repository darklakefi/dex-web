// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.5
// source: api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "darklake.v1";

export enum Network {
  MAINNET_BETA = 0,
  TESTNET = 1,
  DEVNET = 2,
  UNRECOGNIZED = -1,
}

export function networkFromJSON(object: any): Network {
  switch (object) {
    case 0:
    case "MAINNET_BETA":
      return Network.MAINNET_BETA;
    case 1:
    case "TESTNET":
      return Network.TESTNET;
    case 2:
    case "DEVNET":
      return Network.DEVNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Network.UNRECOGNIZED;
  }
}

export function networkToJSON(object: Network): string {
  switch (object) {
    case Network.MAINNET_BETA:
      return "MAINNET_BETA";
    case Network.TESTNET:
      return "TESTNET";
    case Network.DEVNET:
      return "DEVNET";
    case Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TradeStatus {
  UNSIGNED = 0,
  SIGNED = 1,
  CONFIRMED = 2,
  SETTLED = 3,
  SLASHED = 4,
  CANCELLED = 5,
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function tradeStatusFromJSON(object: any): TradeStatus {
  switch (object) {
    case 0:
    case "UNSIGNED":
      return TradeStatus.UNSIGNED;
    case 1:
    case "SIGNED":
      return TradeStatus.SIGNED;
    case 2:
    case "CONFIRMED":
      return TradeStatus.CONFIRMED;
    case 3:
    case "SETTLED":
      return TradeStatus.SETTLED;
    case 4:
    case "SLASHED":
      return TradeStatus.SLASHED;
    case 5:
    case "CANCELLED":
      return TradeStatus.CANCELLED;
    case 6:
    case "FAILED":
      return TradeStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TradeStatus.UNRECOGNIZED;
  }
}

export function tradeStatusToJSON(object: TradeStatus): string {
  switch (object) {
    case TradeStatus.UNSIGNED:
      return "UNSIGNED";
    case TradeStatus.SIGNED:
      return "SIGNED";
    case TradeStatus.CONFIRMED:
      return "CONFIRMED";
    case TradeStatus.SETTLED:
      return "SETTLED";
    case TradeStatus.SLASHED:
      return "SLASHED";
    case TradeStatus.CANCELLED:
      return "CANCELLED";
    case TradeStatus.FAILED:
      return "FAILED";
    case TradeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** --------------------------------- MESSAGES */
export interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  logoUri: string;
  address: string;
}

export interface Trade {
  tradeId: string;
  orderId: string;
  userAddress: string;
  tokenX: TokenMetadata | undefined;
  tokenY: TokenMetadata | undefined;
  amountIn: number;
  minimalAmountOut: number;
  status: TradeStatus;
  signature: string;
  createdAt: number;
  updatedAt: number;
  isSwapXToY: boolean;
}

export interface QuoteRequest {
  tokenMintX: string;
  tokenMintY: string;
  amountIn: number;
  isSwapXToY: boolean;
}

export interface QuoteResponse {
  tokenMintX: string;
  tokenMintY: string;
  isSwapXToY: boolean;
  amountIn: number;
  amountOut: number;
  feeAmount: number;
  feePct: number;
}

export interface CreateUnsignedTransactionRequest {
  userAddress: string;
  tokenMintX: string;
  tokenMintY: string;
  amountIn: number;
  minOut: number;
  trackingId: string;
  isSwapXToY: boolean;
  refCode: string;
  label: string;
}

export interface CreateUnsignedTransactionResponse {
  /** Base64 encoded transaction */
  unsignedTransaction: string;
  orderId: string;
  tradeId: string;
}

export interface SendSignedTransactionRequest {
  signedTransaction: string;
  trackingId: string;
  tradeId: string;
}

export interface SendSignedTransactionResponse {
  success: boolean;
  tradeId: string;
  errorLogs: string[];
}

export interface CheckTradeStatusRequest {
  trackingId: string;
  tradeId: string;
}

export interface CheckTradeStatusResponse {
  tradeId: string;
  status: TradeStatus;
}

export interface GetTradesListByUserRequest {
  userAddress: string;
  pageSize: number;
  pageNumber: number;
}

export interface GetTradesListByUserResponse {
  trades: Trade[];
  totalPages: number;
  currentPage: number;
}

export interface GetTokenMetadataRequest {
  tokenAddress?: string | undefined;
  tokenSymbol?: string | undefined;
  tokenName?: string | undefined;
  substring?: string | undefined;
}

export interface GetTokenMetadataResponse {
  tokenMetadata: TokenMetadata | undefined;
}

export interface TokenAddressesList {
  tokenAddresses: string[];
}

export interface TokenSymbolsList {
  tokenSymbols: string[];
}

export interface TokenNamesList {
  tokenNames: string[];
}

export interface GetTokenMetadataListRequest {
  addressesList?: TokenAddressesList | undefined;
  symbolsList?: TokenSymbolsList | undefined;
  namesList?: TokenNamesList | undefined;
  substring?: string | undefined;
  pageSize: number;
  pageNumber: number;
}

export interface GetTokenMetadataListResponse {
  tokens: TokenMetadata[];
  totalPages: number;
  currentPage: number;
}

/** Custom Token Management Messages */
export interface CreateCustomTokenRequest {
  name: string;
  symbol: string;
  decimals: number;
  logoUri: string;
  address: string;
}

export interface CreateCustomTokenResponse {
  success: boolean;
  message: string;
  tokenMetadata: TokenMetadata | undefined;
}

export interface EditCustomTokenRequest {
  address: string;
  name: string;
  symbol: string;
  decimals: number;
  logoUri: string;
}

export interface EditCustomTokenResponse {
  success: boolean;
  message: string;
  tokenMetadata: TokenMetadata | undefined;
}

export interface DeleteCustomTokenRequest {
  address: string;
}

export interface DeleteCustomTokenResponse {
  success: boolean;
  message: string;
}

export interface GetCustomTokensRequest {
}

export interface GetCustomTokensResponse {
  tokens: TokenMetadata[];
}

export interface GetCustomTokenRequest {
  address: string;
}

export interface GetCustomTokenResponse {
  tokenMetadata: TokenMetadata | undefined;
}

function createBaseTokenMetadata(): TokenMetadata {
  return { name: "", symbol: "", decimals: 0, logoUri: "", address: "" };
}

export const TokenMetadata: MessageFns<TokenMetadata> = {
  encode(message: TokenMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint32(message.decimals);
    }
    if (message.logoUri !== "") {
      writer.uint32(34).string(message.logoUri);
    }
    if (message.address !== "") {
      writer.uint32(42).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logoUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      logoUri: isSet(object.logoUri) ? globalThis.String(object.logoUri) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: TokenMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.logoUri !== "") {
      obj.logoUri = message.logoUri;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenMetadata>, I>>(base?: I): TokenMetadata {
    return TokenMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenMetadata>, I>>(object: I): TokenMetadata {
    const message = createBaseTokenMetadata();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.logoUri = object.logoUri ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    tradeId: "",
    orderId: "",
    userAddress: "",
    tokenX: undefined,
    tokenY: undefined,
    amountIn: 0,
    minimalAmountOut: 0,
    status: 0,
    signature: "",
    createdAt: 0,
    updatedAt: 0,
    isSwapXToY: false,
  };
}

export const Trade: MessageFns<Trade> = {
  encode(message: Trade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId !== "") {
      writer.uint32(10).string(message.tradeId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.userAddress !== "") {
      writer.uint32(26).string(message.userAddress);
    }
    if (message.tokenX !== undefined) {
      TokenMetadata.encode(message.tokenX, writer.uint32(34).fork()).join();
    }
    if (message.tokenY !== undefined) {
      TokenMetadata.encode(message.tokenY, writer.uint32(42).fork()).join();
    }
    if (message.amountIn !== 0) {
      writer.uint32(48).uint64(message.amountIn);
    }
    if (message.minimalAmountOut !== 0) {
      writer.uint32(56).uint64(message.minimalAmountOut);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.signature !== "") {
      writer.uint32(74).string(message.signature);
    }
    if (message.createdAt !== 0) {
      writer.uint32(80).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(88).int64(message.updatedAt);
    }
    if (message.isSwapXToY !== false) {
      writer.uint32(96).bool(message.isSwapXToY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenX = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenY = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amountIn = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minimalAmountOut = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isSwapXToY = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      tokenX: isSet(object.tokenX) ? TokenMetadata.fromJSON(object.tokenX) : undefined,
      tokenY: isSet(object.tokenY) ? TokenMetadata.fromJSON(object.tokenY) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.Number(object.amountIn) : 0,
      minimalAmountOut: isSet(object.minimalAmountOut) ? globalThis.Number(object.minimalAmountOut) : 0,
      status: isSet(object.status) ? tradeStatusFromJSON(object.status) : 0,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      isSwapXToY: isSet(object.isSwapXToY) ? globalThis.Boolean(object.isSwapXToY) : false,
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    if (message.tokenX !== undefined) {
      obj.tokenX = TokenMetadata.toJSON(message.tokenX);
    }
    if (message.tokenY !== undefined) {
      obj.tokenY = TokenMetadata.toJSON(message.tokenY);
    }
    if (message.amountIn !== 0) {
      obj.amountIn = Math.round(message.amountIn);
    }
    if (message.minimalAmountOut !== 0) {
      obj.minimalAmountOut = Math.round(message.minimalAmountOut);
    }
    if (message.status !== 0) {
      obj.status = tradeStatusToJSON(message.status);
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.isSwapXToY !== false) {
      obj.isSwapXToY = message.isSwapXToY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trade>, I>>(base?: I): Trade {
    return Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trade>, I>>(object: I): Trade {
    const message = createBaseTrade();
    message.tradeId = object.tradeId ?? "";
    message.orderId = object.orderId ?? "";
    message.userAddress = object.userAddress ?? "";
    message.tokenX = (object.tokenX !== undefined && object.tokenX !== null)
      ? TokenMetadata.fromPartial(object.tokenX)
      : undefined;
    message.tokenY = (object.tokenY !== undefined && object.tokenY !== null)
      ? TokenMetadata.fromPartial(object.tokenY)
      : undefined;
    message.amountIn = object.amountIn ?? 0;
    message.minimalAmountOut = object.minimalAmountOut ?? 0;
    message.status = object.status ?? 0;
    message.signature = object.signature ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.isSwapXToY = object.isSwapXToY ?? false;
    return message;
  },
};

function createBaseQuoteRequest(): QuoteRequest {
  return { tokenMintX: "", tokenMintY: "", amountIn: 0, isSwapXToY: false };
}

export const QuoteRequest: MessageFns<QuoteRequest> = {
  encode(message: QuoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenMintX !== "") {
      writer.uint32(10).string(message.tokenMintX);
    }
    if (message.tokenMintY !== "") {
      writer.uint32(18).string(message.tokenMintY);
    }
    if (message.amountIn !== 0) {
      writer.uint32(24).uint64(message.amountIn);
    }
    if (message.isSwapXToY !== false) {
      writer.uint32(32).bool(message.isSwapXToY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenMintX = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenMintY = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountIn = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSwapXToY = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteRequest {
    return {
      tokenMintX: isSet(object.tokenMintX) ? globalThis.String(object.tokenMintX) : "",
      tokenMintY: isSet(object.tokenMintY) ? globalThis.String(object.tokenMintY) : "",
      amountIn: isSet(object.amountIn) ? globalThis.Number(object.amountIn) : 0,
      isSwapXToY: isSet(object.isSwapXToY) ? globalThis.Boolean(object.isSwapXToY) : false,
    };
  },

  toJSON(message: QuoteRequest): unknown {
    const obj: any = {};
    if (message.tokenMintX !== "") {
      obj.tokenMintX = message.tokenMintX;
    }
    if (message.tokenMintY !== "") {
      obj.tokenMintY = message.tokenMintY;
    }
    if (message.amountIn !== 0) {
      obj.amountIn = Math.round(message.amountIn);
    }
    if (message.isSwapXToY !== false) {
      obj.isSwapXToY = message.isSwapXToY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequest>, I>>(base?: I): QuoteRequest {
    return QuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequest>, I>>(object: I): QuoteRequest {
    const message = createBaseQuoteRequest();
    message.tokenMintX = object.tokenMintX ?? "";
    message.tokenMintY = object.tokenMintY ?? "";
    message.amountIn = object.amountIn ?? 0;
    message.isSwapXToY = object.isSwapXToY ?? false;
    return message;
  },
};

function createBaseQuoteResponse(): QuoteResponse {
  return { tokenMintX: "", tokenMintY: "", isSwapXToY: false, amountIn: 0, amountOut: 0, feeAmount: 0, feePct: 0 };
}

export const QuoteResponse: MessageFns<QuoteResponse> = {
  encode(message: QuoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenMintX !== "") {
      writer.uint32(10).string(message.tokenMintX);
    }
    if (message.tokenMintY !== "") {
      writer.uint32(18).string(message.tokenMintY);
    }
    if (message.isSwapXToY !== false) {
      writer.uint32(24).bool(message.isSwapXToY);
    }
    if (message.amountIn !== 0) {
      writer.uint32(32).uint64(message.amountIn);
    }
    if (message.amountOut !== 0) {
      writer.uint32(40).uint64(message.amountOut);
    }
    if (message.feeAmount !== 0) {
      writer.uint32(48).uint64(message.feeAmount);
    }
    if (message.feePct !== 0) {
      writer.uint32(57).double(message.feePct);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenMintX = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenMintY = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSwapXToY = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountIn = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amountOut = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.feeAmount = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.feePct = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteResponse {
    return {
      tokenMintX: isSet(object.tokenMintX) ? globalThis.String(object.tokenMintX) : "",
      tokenMintY: isSet(object.tokenMintY) ? globalThis.String(object.tokenMintY) : "",
      isSwapXToY: isSet(object.isSwapXToY) ? globalThis.Boolean(object.isSwapXToY) : false,
      amountIn: isSet(object.amountIn) ? globalThis.Number(object.amountIn) : 0,
      amountOut: isSet(object.amountOut) ? globalThis.Number(object.amountOut) : 0,
      feeAmount: isSet(object.feeAmount) ? globalThis.Number(object.feeAmount) : 0,
      feePct: isSet(object.feePct) ? globalThis.Number(object.feePct) : 0,
    };
  },

  toJSON(message: QuoteResponse): unknown {
    const obj: any = {};
    if (message.tokenMintX !== "") {
      obj.tokenMintX = message.tokenMintX;
    }
    if (message.tokenMintY !== "") {
      obj.tokenMintY = message.tokenMintY;
    }
    if (message.isSwapXToY !== false) {
      obj.isSwapXToY = message.isSwapXToY;
    }
    if (message.amountIn !== 0) {
      obj.amountIn = Math.round(message.amountIn);
    }
    if (message.amountOut !== 0) {
      obj.amountOut = Math.round(message.amountOut);
    }
    if (message.feeAmount !== 0) {
      obj.feeAmount = Math.round(message.feeAmount);
    }
    if (message.feePct !== 0) {
      obj.feePct = message.feePct;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteResponse>, I>>(base?: I): QuoteResponse {
    return QuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteResponse>, I>>(object: I): QuoteResponse {
    const message = createBaseQuoteResponse();
    message.tokenMintX = object.tokenMintX ?? "";
    message.tokenMintY = object.tokenMintY ?? "";
    message.isSwapXToY = object.isSwapXToY ?? false;
    message.amountIn = object.amountIn ?? 0;
    message.amountOut = object.amountOut ?? 0;
    message.feeAmount = object.feeAmount ?? 0;
    message.feePct = object.feePct ?? 0;
    return message;
  },
};

function createBaseCreateUnsignedTransactionRequest(): CreateUnsignedTransactionRequest {
  return {
    userAddress: "",
    tokenMintX: "",
    tokenMintY: "",
    amountIn: 0,
    minOut: 0,
    trackingId: "",
    isSwapXToY: false,
    refCode: "",
    label: "",
  };
}

export const CreateUnsignedTransactionRequest: MessageFns<CreateUnsignedTransactionRequest> = {
  encode(message: CreateUnsignedTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAddress !== "") {
      writer.uint32(10).string(message.userAddress);
    }
    if (message.tokenMintX !== "") {
      writer.uint32(18).string(message.tokenMintX);
    }
    if (message.tokenMintY !== "") {
      writer.uint32(26).string(message.tokenMintY);
    }
    if (message.amountIn !== 0) {
      writer.uint32(32).uint64(message.amountIn);
    }
    if (message.minOut !== 0) {
      writer.uint32(40).uint64(message.minOut);
    }
    if (message.trackingId !== "") {
      writer.uint32(50).string(message.trackingId);
    }
    if (message.isSwapXToY !== false) {
      writer.uint32(56).bool(message.isSwapXToY);
    }
    if (message.refCode !== "") {
      writer.uint32(66).string(message.refCode);
    }
    if (message.label !== "") {
      writer.uint32(74).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUnsignedTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUnsignedTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenMintX = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenMintY = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountIn = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.minOut = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isSwapXToY = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.refCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUnsignedTransactionRequest {
    return {
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      tokenMintX: isSet(object.tokenMintX) ? globalThis.String(object.tokenMintX) : "",
      tokenMintY: isSet(object.tokenMintY) ? globalThis.String(object.tokenMintY) : "",
      amountIn: isSet(object.amountIn) ? globalThis.Number(object.amountIn) : 0,
      minOut: isSet(object.minOut) ? globalThis.Number(object.minOut) : 0,
      trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "",
      isSwapXToY: isSet(object.isSwapXToY) ? globalThis.Boolean(object.isSwapXToY) : false,
      refCode: isSet(object.refCode) ? globalThis.String(object.refCode) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: CreateUnsignedTransactionRequest): unknown {
    const obj: any = {};
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    if (message.tokenMintX !== "") {
      obj.tokenMintX = message.tokenMintX;
    }
    if (message.tokenMintY !== "") {
      obj.tokenMintY = message.tokenMintY;
    }
    if (message.amountIn !== 0) {
      obj.amountIn = Math.round(message.amountIn);
    }
    if (message.minOut !== 0) {
      obj.minOut = Math.round(message.minOut);
    }
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    if (message.isSwapXToY !== false) {
      obj.isSwapXToY = message.isSwapXToY;
    }
    if (message.refCode !== "") {
      obj.refCode = message.refCode;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUnsignedTransactionRequest>, I>>(
    base?: I,
  ): CreateUnsignedTransactionRequest {
    return CreateUnsignedTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUnsignedTransactionRequest>, I>>(
    object: I,
  ): CreateUnsignedTransactionRequest {
    const message = createBaseCreateUnsignedTransactionRequest();
    message.userAddress = object.userAddress ?? "";
    message.tokenMintX = object.tokenMintX ?? "";
    message.tokenMintY = object.tokenMintY ?? "";
    message.amountIn = object.amountIn ?? 0;
    message.minOut = object.minOut ?? 0;
    message.trackingId = object.trackingId ?? "";
    message.isSwapXToY = object.isSwapXToY ?? false;
    message.refCode = object.refCode ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseCreateUnsignedTransactionResponse(): CreateUnsignedTransactionResponse {
  return { unsignedTransaction: "", orderId: "", tradeId: "" };
}

export const CreateUnsignedTransactionResponse: MessageFns<CreateUnsignedTransactionResponse> = {
  encode(message: CreateUnsignedTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unsignedTransaction !== "") {
      writer.uint32(10).string(message.unsignedTransaction);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.tradeId !== "") {
      writer.uint32(26).string(message.tradeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUnsignedTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUnsignedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unsignedTransaction = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUnsignedTransactionResponse {
    return {
      unsignedTransaction: isSet(object.unsignedTransaction) ? globalThis.String(object.unsignedTransaction) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
    };
  },

  toJSON(message: CreateUnsignedTransactionResponse): unknown {
    const obj: any = {};
    if (message.unsignedTransaction !== "") {
      obj.unsignedTransaction = message.unsignedTransaction;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUnsignedTransactionResponse>, I>>(
    base?: I,
  ): CreateUnsignedTransactionResponse {
    return CreateUnsignedTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUnsignedTransactionResponse>, I>>(
    object: I,
  ): CreateUnsignedTransactionResponse {
    const message = createBaseCreateUnsignedTransactionResponse();
    message.unsignedTransaction = object.unsignedTransaction ?? "";
    message.orderId = object.orderId ?? "";
    message.tradeId = object.tradeId ?? "";
    return message;
  },
};

function createBaseSendSignedTransactionRequest(): SendSignedTransactionRequest {
  return { signedTransaction: "", trackingId: "", tradeId: "" };
}

export const SendSignedTransactionRequest: MessageFns<SendSignedTransactionRequest> = {
  encode(message: SendSignedTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedTransaction !== "") {
      writer.uint32(10).string(message.signedTransaction);
    }
    if (message.trackingId !== "") {
      writer.uint32(18).string(message.trackingId);
    }
    if (message.tradeId !== "") {
      writer.uint32(26).string(message.tradeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendSignedTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendSignedTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signedTransaction = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendSignedTransactionRequest {
    return {
      signedTransaction: isSet(object.signedTransaction) ? globalThis.String(object.signedTransaction) : "",
      trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "",
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
    };
  },

  toJSON(message: SendSignedTransactionRequest): unknown {
    const obj: any = {};
    if (message.signedTransaction !== "") {
      obj.signedTransaction = message.signedTransaction;
    }
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendSignedTransactionRequest>, I>>(base?: I): SendSignedTransactionRequest {
    return SendSignedTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendSignedTransactionRequest>, I>>(object: I): SendSignedTransactionRequest {
    const message = createBaseSendSignedTransactionRequest();
    message.signedTransaction = object.signedTransaction ?? "";
    message.trackingId = object.trackingId ?? "";
    message.tradeId = object.tradeId ?? "";
    return message;
  },
};

function createBaseSendSignedTransactionResponse(): SendSignedTransactionResponse {
  return { success: false, tradeId: "", errorLogs: [] };
}

export const SendSignedTransactionResponse: MessageFns<SendSignedTransactionResponse> = {
  encode(message: SendSignedTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.tradeId !== "") {
      writer.uint32(18).string(message.tradeId);
    }
    for (const v of message.errorLogs) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendSignedTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendSignedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorLogs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendSignedTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
      errorLogs: globalThis.Array.isArray(object?.errorLogs)
        ? object.errorLogs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SendSignedTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    if (message.errorLogs?.length) {
      obj.errorLogs = message.errorLogs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendSignedTransactionResponse>, I>>(base?: I): SendSignedTransactionResponse {
    return SendSignedTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendSignedTransactionResponse>, I>>(
    object: I,
  ): SendSignedTransactionResponse {
    const message = createBaseSendSignedTransactionResponse();
    message.success = object.success ?? false;
    message.tradeId = object.tradeId ?? "";
    message.errorLogs = object.errorLogs?.map((e) => e) || [];
    return message;
  },
};

function createBaseCheckTradeStatusRequest(): CheckTradeStatusRequest {
  return { trackingId: "", tradeId: "" };
}

export const CheckTradeStatusRequest: MessageFns<CheckTradeStatusRequest> = {
  encode(message: CheckTradeStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    if (message.tradeId !== "") {
      writer.uint32(18).string(message.tradeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckTradeStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckTradeStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckTradeStatusRequest {
    return {
      trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "",
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
    };
  },

  toJSON(message: CheckTradeStatusRequest): unknown {
    const obj: any = {};
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckTradeStatusRequest>, I>>(base?: I): CheckTradeStatusRequest {
    return CheckTradeStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckTradeStatusRequest>, I>>(object: I): CheckTradeStatusRequest {
    const message = createBaseCheckTradeStatusRequest();
    message.trackingId = object.trackingId ?? "";
    message.tradeId = object.tradeId ?? "";
    return message;
  },
};

function createBaseCheckTradeStatusResponse(): CheckTradeStatusResponse {
  return { tradeId: "", status: 0 };
}

export const CheckTradeStatusResponse: MessageFns<CheckTradeStatusResponse> = {
  encode(message: CheckTradeStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId !== "") {
      writer.uint32(10).string(message.tradeId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckTradeStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckTradeStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckTradeStatusResponse {
    return {
      tradeId: isSet(object.tradeId) ? globalThis.String(object.tradeId) : "",
      status: isSet(object.status) ? tradeStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: CheckTradeStatusResponse): unknown {
    const obj: any = {};
    if (message.tradeId !== "") {
      obj.tradeId = message.tradeId;
    }
    if (message.status !== 0) {
      obj.status = tradeStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckTradeStatusResponse>, I>>(base?: I): CheckTradeStatusResponse {
    return CheckTradeStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckTradeStatusResponse>, I>>(object: I): CheckTradeStatusResponse {
    const message = createBaseCheckTradeStatusResponse();
    message.tradeId = object.tradeId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetTradesListByUserRequest(): GetTradesListByUserRequest {
  return { userAddress: "", pageSize: 0, pageNumber: 0 };
}

export const GetTradesListByUserRequest: MessageFns<GetTradesListByUserRequest> = {
  encode(message: GetTradesListByUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAddress !== "") {
      writer.uint32(10).string(message.userAddress);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(24).int32(message.pageNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradesListByUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradesListByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradesListByUserRequest {
    return {
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
    };
  },

  toJSON(message: GetTradesListByUserRequest): unknown {
    const obj: any = {};
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradesListByUserRequest>, I>>(base?: I): GetTradesListByUserRequest {
    return GetTradesListByUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradesListByUserRequest>, I>>(object: I): GetTradesListByUserRequest {
    const message = createBaseGetTradesListByUserRequest();
    message.userAddress = object.userAddress ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageNumber = object.pageNumber ?? 0;
    return message;
  },
};

function createBaseGetTradesListByUserResponse(): GetTradesListByUserResponse {
  return { trades: [], totalPages: 0, currentPage: 0 };
}

export const GetTradesListByUserResponse: MessageFns<GetTradesListByUserResponse> = {
  encode(message: GetTradesListByUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trades) {
      Trade.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradesListByUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradesListByUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trades.push(Trade.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradesListByUserResponse {
    return {
      trades: globalThis.Array.isArray(object?.trades) ? object.trades.map((e: any) => Trade.fromJSON(e)) : [],
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
    };
  },

  toJSON(message: GetTradesListByUserResponse): unknown {
    const obj: any = {};
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => Trade.toJSON(e));
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradesListByUserResponse>, I>>(base?: I): GetTradesListByUserResponse {
    return GetTradesListByUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradesListByUserResponse>, I>>(object: I): GetTradesListByUserResponse {
    const message = createBaseGetTradesListByUserResponse();
    message.trades = object.trades?.map((e) => Trade.fromPartial(e)) || [];
    message.totalPages = object.totalPages ?? 0;
    message.currentPage = object.currentPage ?? 0;
    return message;
  },
};

function createBaseGetTokenMetadataRequest(): GetTokenMetadataRequest {
  return { tokenAddress: undefined, tokenSymbol: undefined, tokenName: undefined, substring: undefined };
}

export const GetTokenMetadataRequest: MessageFns<GetTokenMetadataRequest> = {
  encode(message: GetTokenMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenAddress !== undefined) {
      writer.uint32(10).string(message.tokenAddress);
    }
    if (message.tokenSymbol !== undefined) {
      writer.uint32(18).string(message.tokenSymbol);
    }
    if (message.tokenName !== undefined) {
      writer.uint32(26).string(message.tokenName);
    }
    if (message.substring !== undefined) {
      writer.uint32(34).string(message.substring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenSymbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substring = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenMetadataRequest {
    return {
      tokenAddress: isSet(object.tokenAddress) ? globalThis.String(object.tokenAddress) : undefined,
      tokenSymbol: isSet(object.tokenSymbol) ? globalThis.String(object.tokenSymbol) : undefined,
      tokenName: isSet(object.tokenName) ? globalThis.String(object.tokenName) : undefined,
      substring: isSet(object.substring) ? globalThis.String(object.substring) : undefined,
    };
  },

  toJSON(message: GetTokenMetadataRequest): unknown {
    const obj: any = {};
    if (message.tokenAddress !== undefined) {
      obj.tokenAddress = message.tokenAddress;
    }
    if (message.tokenSymbol !== undefined) {
      obj.tokenSymbol = message.tokenSymbol;
    }
    if (message.tokenName !== undefined) {
      obj.tokenName = message.tokenName;
    }
    if (message.substring !== undefined) {
      obj.substring = message.substring;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenMetadataRequest>, I>>(base?: I): GetTokenMetadataRequest {
    return GetTokenMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenMetadataRequest>, I>>(object: I): GetTokenMetadataRequest {
    const message = createBaseGetTokenMetadataRequest();
    message.tokenAddress = object.tokenAddress ?? undefined;
    message.tokenSymbol = object.tokenSymbol ?? undefined;
    message.tokenName = object.tokenName ?? undefined;
    message.substring = object.substring ?? undefined;
    return message;
  },
};

function createBaseGetTokenMetadataResponse(): GetTokenMetadataResponse {
  return { tokenMetadata: undefined };
}

export const GetTokenMetadataResponse: MessageFns<GetTokenMetadataResponse> = {
  encode(message: GetTokenMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenMetadata !== undefined) {
      TokenMetadata.encode(message.tokenMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenMetadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenMetadataResponse {
    return { tokenMetadata: isSet(object.tokenMetadata) ? TokenMetadata.fromJSON(object.tokenMetadata) : undefined };
  },

  toJSON(message: GetTokenMetadataResponse): unknown {
    const obj: any = {};
    if (message.tokenMetadata !== undefined) {
      obj.tokenMetadata = TokenMetadata.toJSON(message.tokenMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenMetadataResponse>, I>>(base?: I): GetTokenMetadataResponse {
    return GetTokenMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenMetadataResponse>, I>>(object: I): GetTokenMetadataResponse {
    const message = createBaseGetTokenMetadataResponse();
    message.tokenMetadata = (object.tokenMetadata !== undefined && object.tokenMetadata !== null)
      ? TokenMetadata.fromPartial(object.tokenMetadata)
      : undefined;
    return message;
  },
};

function createBaseTokenAddressesList(): TokenAddressesList {
  return { tokenAddresses: [] };
}

export const TokenAddressesList: MessageFns<TokenAddressesList> = {
  encode(message: TokenAddressesList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenAddresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenAddressesList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenAddressesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenAddresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenAddressesList {
    return {
      tokenAddresses: globalThis.Array.isArray(object?.tokenAddresses)
        ? object.tokenAddresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TokenAddressesList): unknown {
    const obj: any = {};
    if (message.tokenAddresses?.length) {
      obj.tokenAddresses = message.tokenAddresses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenAddressesList>, I>>(base?: I): TokenAddressesList {
    return TokenAddressesList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenAddressesList>, I>>(object: I): TokenAddressesList {
    const message = createBaseTokenAddressesList();
    message.tokenAddresses = object.tokenAddresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseTokenSymbolsList(): TokenSymbolsList {
  return { tokenSymbols: [] };
}

export const TokenSymbolsList: MessageFns<TokenSymbolsList> = {
  encode(message: TokenSymbolsList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenSymbols) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenSymbolsList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenSymbolsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenSymbols.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenSymbolsList {
    return {
      tokenSymbols: globalThis.Array.isArray(object?.tokenSymbols)
        ? object.tokenSymbols.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TokenSymbolsList): unknown {
    const obj: any = {};
    if (message.tokenSymbols?.length) {
      obj.tokenSymbols = message.tokenSymbols;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenSymbolsList>, I>>(base?: I): TokenSymbolsList {
    return TokenSymbolsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenSymbolsList>, I>>(object: I): TokenSymbolsList {
    const message = createBaseTokenSymbolsList();
    message.tokenSymbols = object.tokenSymbols?.map((e) => e) || [];
    return message;
  },
};

function createBaseTokenNamesList(): TokenNamesList {
  return { tokenNames: [] };
}

export const TokenNamesList: MessageFns<TokenNamesList> = {
  encode(message: TokenNamesList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenNamesList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenNamesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenNamesList {
    return {
      tokenNames: globalThis.Array.isArray(object?.tokenNames)
        ? object.tokenNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TokenNamesList): unknown {
    const obj: any = {};
    if (message.tokenNames?.length) {
      obj.tokenNames = message.tokenNames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenNamesList>, I>>(base?: I): TokenNamesList {
    return TokenNamesList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenNamesList>, I>>(object: I): TokenNamesList {
    const message = createBaseTokenNamesList();
    message.tokenNames = object.tokenNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTokenMetadataListRequest(): GetTokenMetadataListRequest {
  return {
    addressesList: undefined,
    symbolsList: undefined,
    namesList: undefined,
    substring: undefined,
    pageSize: 0,
    pageNumber: 0,
  };
}

export const GetTokenMetadataListRequest: MessageFns<GetTokenMetadataListRequest> = {
  encode(message: GetTokenMetadataListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressesList !== undefined) {
      TokenAddressesList.encode(message.addressesList, writer.uint32(10).fork()).join();
    }
    if (message.symbolsList !== undefined) {
      TokenSymbolsList.encode(message.symbolsList, writer.uint32(18).fork()).join();
    }
    if (message.namesList !== undefined) {
      TokenNamesList.encode(message.namesList, writer.uint32(26).fork()).join();
    }
    if (message.substring !== undefined) {
      writer.uint32(50).string(message.substring);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(40).int32(message.pageNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenMetadataListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenMetadataListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressesList = TokenAddressesList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbolsList = TokenSymbolsList.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namesList = TokenNamesList.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.substring = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenMetadataListRequest {
    return {
      addressesList: isSet(object.addressesList) ? TokenAddressesList.fromJSON(object.addressesList) : undefined,
      symbolsList: isSet(object.symbolsList) ? TokenSymbolsList.fromJSON(object.symbolsList) : undefined,
      namesList: isSet(object.namesList) ? TokenNamesList.fromJSON(object.namesList) : undefined,
      substring: isSet(object.substring) ? globalThis.String(object.substring) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
    };
  },

  toJSON(message: GetTokenMetadataListRequest): unknown {
    const obj: any = {};
    if (message.addressesList !== undefined) {
      obj.addressesList = TokenAddressesList.toJSON(message.addressesList);
    }
    if (message.symbolsList !== undefined) {
      obj.symbolsList = TokenSymbolsList.toJSON(message.symbolsList);
    }
    if (message.namesList !== undefined) {
      obj.namesList = TokenNamesList.toJSON(message.namesList);
    }
    if (message.substring !== undefined) {
      obj.substring = message.substring;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenMetadataListRequest>, I>>(base?: I): GetTokenMetadataListRequest {
    return GetTokenMetadataListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenMetadataListRequest>, I>>(object: I): GetTokenMetadataListRequest {
    const message = createBaseGetTokenMetadataListRequest();
    message.addressesList = (object.addressesList !== undefined && object.addressesList !== null)
      ? TokenAddressesList.fromPartial(object.addressesList)
      : undefined;
    message.symbolsList = (object.symbolsList !== undefined && object.symbolsList !== null)
      ? TokenSymbolsList.fromPartial(object.symbolsList)
      : undefined;
    message.namesList = (object.namesList !== undefined && object.namesList !== null)
      ? TokenNamesList.fromPartial(object.namesList)
      : undefined;
    message.substring = object.substring ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageNumber = object.pageNumber ?? 0;
    return message;
  },
};

function createBaseGetTokenMetadataListResponse(): GetTokenMetadataListResponse {
  return { tokens: [], totalPages: 0, currentPage: 0 };
}

export const GetTokenMetadataListResponse: MessageFns<GetTokenMetadataListResponse> = {
  encode(message: GetTokenMetadataListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokens) {
      TokenMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenMetadataListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenMetadataListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenMetadataListResponse {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => TokenMetadata.fromJSON(e)) : [],
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
    };
  },

  toJSON(message: GetTokenMetadataListResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => TokenMetadata.toJSON(e));
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenMetadataListResponse>, I>>(base?: I): GetTokenMetadataListResponse {
    return GetTokenMetadataListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenMetadataListResponse>, I>>(object: I): GetTokenMetadataListResponse {
    const message = createBaseGetTokenMetadataListResponse();
    message.tokens = object.tokens?.map((e) => TokenMetadata.fromPartial(e)) || [];
    message.totalPages = object.totalPages ?? 0;
    message.currentPage = object.currentPage ?? 0;
    return message;
  },
};

function createBaseCreateCustomTokenRequest(): CreateCustomTokenRequest {
  return { name: "", symbol: "", decimals: 0, logoUri: "", address: "" };
}

export const CreateCustomTokenRequest: MessageFns<CreateCustomTokenRequest> = {
  encode(message: CreateCustomTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint32(message.decimals);
    }
    if (message.logoUri !== "") {
      writer.uint32(34).string(message.logoUri);
    }
    if (message.address !== "") {
      writer.uint32(42).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logoUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      logoUri: isSet(object.logoUri) ? globalThis.String(object.logoUri) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: CreateCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.logoUri !== "") {
      obj.logoUri = message.logoUri;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(base?: I): CreateCustomTokenRequest {
    return CreateCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenRequest>, I>>(object: I): CreateCustomTokenRequest {
    const message = createBaseCreateCustomTokenRequest();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.logoUri = object.logoUri ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseCreateCustomTokenResponse(): CreateCustomTokenResponse {
  return { success: false, message: "", tokenMetadata: undefined };
}

export const CreateCustomTokenResponse: MessageFns<CreateCustomTokenResponse> = {
  encode(message: CreateCustomTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.tokenMetadata !== undefined) {
      TokenMetadata.encode(message.tokenMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenMetadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      tokenMetadata: isSet(object.tokenMetadata) ? TokenMetadata.fromJSON(object.tokenMetadata) : undefined,
    };
  },

  toJSON(message: CreateCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.tokenMetadata !== undefined) {
      obj.tokenMetadata = TokenMetadata.toJSON(message.tokenMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(base?: I): CreateCustomTokenResponse {
    return CreateCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomTokenResponse>, I>>(object: I): CreateCustomTokenResponse {
    const message = createBaseCreateCustomTokenResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.tokenMetadata = (object.tokenMetadata !== undefined && object.tokenMetadata !== null)
      ? TokenMetadata.fromPartial(object.tokenMetadata)
      : undefined;
    return message;
  },
};

function createBaseEditCustomTokenRequest(): EditCustomTokenRequest {
  return { address: "", name: "", symbol: "", decimals: 0, logoUri: "" };
}

export const EditCustomTokenRequest: MessageFns<EditCustomTokenRequest> = {
  encode(message: EditCustomTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint32(message.decimals);
    }
    if (message.logoUri !== "") {
      writer.uint32(42).string(message.logoUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditCustomTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.logoUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditCustomTokenRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      logoUri: isSet(object.logoUri) ? globalThis.String(object.logoUri) : "",
    };
  },

  toJSON(message: EditCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.logoUri !== "") {
      obj.logoUri = message.logoUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditCustomTokenRequest>, I>>(base?: I): EditCustomTokenRequest {
    return EditCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditCustomTokenRequest>, I>>(object: I): EditCustomTokenRequest {
    const message = createBaseEditCustomTokenRequest();
    message.address = object.address ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.logoUri = object.logoUri ?? "";
    return message;
  },
};

function createBaseEditCustomTokenResponse(): EditCustomTokenResponse {
  return { success: false, message: "", tokenMetadata: undefined };
}

export const EditCustomTokenResponse: MessageFns<EditCustomTokenResponse> = {
  encode(message: EditCustomTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.tokenMetadata !== undefined) {
      TokenMetadata.encode(message.tokenMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditCustomTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenMetadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditCustomTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      tokenMetadata: isSet(object.tokenMetadata) ? TokenMetadata.fromJSON(object.tokenMetadata) : undefined,
    };
  },

  toJSON(message: EditCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.tokenMetadata !== undefined) {
      obj.tokenMetadata = TokenMetadata.toJSON(message.tokenMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditCustomTokenResponse>, I>>(base?: I): EditCustomTokenResponse {
    return EditCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditCustomTokenResponse>, I>>(object: I): EditCustomTokenResponse {
    const message = createBaseEditCustomTokenResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.tokenMetadata = (object.tokenMetadata !== undefined && object.tokenMetadata !== null)
      ? TokenMetadata.fromPartial(object.tokenMetadata)
      : undefined;
    return message;
  },
};

function createBaseDeleteCustomTokenRequest(): DeleteCustomTokenRequest {
  return { address: "" };
}

export const DeleteCustomTokenRequest: MessageFns<DeleteCustomTokenRequest> = {
  encode(message: DeleteCustomTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCustomTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCustomTokenRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: DeleteCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCustomTokenRequest>, I>>(base?: I): DeleteCustomTokenRequest {
    return DeleteCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCustomTokenRequest>, I>>(object: I): DeleteCustomTokenRequest {
    const message = createBaseDeleteCustomTokenRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseDeleteCustomTokenResponse(): DeleteCustomTokenResponse {
  return { success: false, message: "" };
}

export const DeleteCustomTokenResponse: MessageFns<DeleteCustomTokenResponse> = {
  encode(message: DeleteCustomTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCustomTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCustomTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCustomTokenResponse>, I>>(base?: I): DeleteCustomTokenResponse {
    return DeleteCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCustomTokenResponse>, I>>(object: I): DeleteCustomTokenResponse {
    const message = createBaseDeleteCustomTokenResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetCustomTokensRequest(): GetCustomTokensRequest {
  return {};
}

export const GetCustomTokensRequest: MessageFns<GetCustomTokensRequest> = {
  encode(_: GetCustomTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetCustomTokensRequest {
    return {};
  },

  toJSON(_: GetCustomTokensRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCustomTokensRequest>, I>>(base?: I): GetCustomTokensRequest {
    return GetCustomTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCustomTokensRequest>, I>>(_: I): GetCustomTokensRequest {
    const message = createBaseGetCustomTokensRequest();
    return message;
  },
};

function createBaseGetCustomTokensResponse(): GetCustomTokensResponse {
  return { tokens: [] };
}

export const GetCustomTokensResponse: MessageFns<GetCustomTokensResponse> = {
  encode(message: GetCustomTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokens) {
      TokenMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens.push(TokenMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomTokensResponse {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => TokenMetadata.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCustomTokensResponse): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => TokenMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCustomTokensResponse>, I>>(base?: I): GetCustomTokensResponse {
    return GetCustomTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCustomTokensResponse>, I>>(object: I): GetCustomTokensResponse {
    const message = createBaseGetCustomTokensResponse();
    message.tokens = object.tokens?.map((e) => TokenMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCustomTokenRequest(): GetCustomTokenRequest {
  return { address: "" };
}

export const GetCustomTokenRequest: MessageFns<GetCustomTokenRequest> = {
  encode(message: GetCustomTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomTokenRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: GetCustomTokenRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCustomTokenRequest>, I>>(base?: I): GetCustomTokenRequest {
    return GetCustomTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCustomTokenRequest>, I>>(object: I): GetCustomTokenRequest {
    const message = createBaseGetCustomTokenRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetCustomTokenResponse(): GetCustomTokenResponse {
  return { tokenMetadata: undefined };
}

export const GetCustomTokenResponse: MessageFns<GetCustomTokenResponse> = {
  encode(message: GetCustomTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenMetadata !== undefined) {
      TokenMetadata.encode(message.tokenMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenMetadata = TokenMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomTokenResponse {
    return { tokenMetadata: isSet(object.tokenMetadata) ? TokenMetadata.fromJSON(object.tokenMetadata) : undefined };
  },

  toJSON(message: GetCustomTokenResponse): unknown {
    const obj: any = {};
    if (message.tokenMetadata !== undefined) {
      obj.tokenMetadata = TokenMetadata.toJSON(message.tokenMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCustomTokenResponse>, I>>(base?: I): GetCustomTokenResponse {
    return GetCustomTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCustomTokenResponse>, I>>(object: I): GetCustomTokenResponse {
    const message = createBaseGetCustomTokenResponse();
    message.tokenMetadata = (object.tokenMetadata !== undefined && object.tokenMetadata !== null)
      ? TokenMetadata.fromPartial(object.tokenMetadata)
      : undefined;
    return message;
  },
};

export interface SolanaGatewayService {
  CreateUnsignedTransaction(request: CreateUnsignedTransactionRequest): Promise<CreateUnsignedTransactionResponse>;
  SendSignedTransaction(request: SendSignedTransactionRequest): Promise<SendSignedTransactionResponse>;
  CheckTradeStatus(request: CheckTradeStatusRequest): Promise<CheckTradeStatusResponse>;
  GetTradesListByUser(request: GetTradesListByUserRequest): Promise<GetTradesListByUserResponse>;
  GetTokenMetadata(request: GetTokenMetadataRequest): Promise<GetTokenMetadataResponse>;
  GetTokenMetadataList(request: GetTokenMetadataListRequest): Promise<GetTokenMetadataListResponse>;
  CreateCustomToken(request: CreateCustomTokenRequest): Promise<CreateCustomTokenResponse>;
  EditCustomToken(request: EditCustomTokenRequest): Promise<EditCustomTokenResponse>;
  DeleteCustomToken(request: DeleteCustomTokenRequest): Promise<DeleteCustomTokenResponse>;
  GetCustomTokens(request: GetCustomTokensRequest): Promise<GetCustomTokensResponse>;
  GetCustomToken(request: GetCustomTokenRequest): Promise<GetCustomTokenResponse>;
}

export const SolanaGatewayServiceServiceName = "darklake.v1.SolanaGatewayService";
export class SolanaGatewayServiceClientImpl implements SolanaGatewayService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SolanaGatewayServiceServiceName;
    this.rpc = rpc;
    this.CreateUnsignedTransaction = this.CreateUnsignedTransaction.bind(this);
    this.SendSignedTransaction = this.SendSignedTransaction.bind(this);
    this.CheckTradeStatus = this.CheckTradeStatus.bind(this);
    this.GetTradesListByUser = this.GetTradesListByUser.bind(this);
    this.GetTokenMetadata = this.GetTokenMetadata.bind(this);
    this.GetTokenMetadataList = this.GetTokenMetadataList.bind(this);
    this.CreateCustomToken = this.CreateCustomToken.bind(this);
    this.EditCustomToken = this.EditCustomToken.bind(this);
    this.DeleteCustomToken = this.DeleteCustomToken.bind(this);
    this.GetCustomTokens = this.GetCustomTokens.bind(this);
    this.GetCustomToken = this.GetCustomToken.bind(this);
  }
  CreateUnsignedTransaction(request: CreateUnsignedTransactionRequest): Promise<CreateUnsignedTransactionResponse> {
    const data = CreateUnsignedTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUnsignedTransaction", data);
    return promise.then((data) => CreateUnsignedTransactionResponse.decode(new BinaryReader(data)));
  }

  SendSignedTransaction(request: SendSignedTransactionRequest): Promise<SendSignedTransactionResponse> {
    const data = SendSignedTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendSignedTransaction", data);
    return promise.then((data) => SendSignedTransactionResponse.decode(new BinaryReader(data)));
  }

  CheckTradeStatus(request: CheckTradeStatusRequest): Promise<CheckTradeStatusResponse> {
    const data = CheckTradeStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckTradeStatus", data);
    return promise.then((data) => CheckTradeStatusResponse.decode(new BinaryReader(data)));
  }

  GetTradesListByUser(request: GetTradesListByUserRequest): Promise<GetTradesListByUserResponse> {
    const data = GetTradesListByUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTradesListByUser", data);
    return promise.then((data) => GetTradesListByUserResponse.decode(new BinaryReader(data)));
  }

  GetTokenMetadata(request: GetTokenMetadataRequest): Promise<GetTokenMetadataResponse> {
    const data = GetTokenMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokenMetadata", data);
    return promise.then((data) => GetTokenMetadataResponse.decode(new BinaryReader(data)));
  }

  GetTokenMetadataList(request: GetTokenMetadataListRequest): Promise<GetTokenMetadataListResponse> {
    const data = GetTokenMetadataListRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokenMetadataList", data);
    return promise.then((data) => GetTokenMetadataListResponse.decode(new BinaryReader(data)));
  }

  CreateCustomToken(request: CreateCustomTokenRequest): Promise<CreateCustomTokenResponse> {
    const data = CreateCustomTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateCustomToken", data);
    return promise.then((data) => CreateCustomTokenResponse.decode(new BinaryReader(data)));
  }

  EditCustomToken(request: EditCustomTokenRequest): Promise<EditCustomTokenResponse> {
    const data = EditCustomTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EditCustomToken", data);
    return promise.then((data) => EditCustomTokenResponse.decode(new BinaryReader(data)));
  }

  DeleteCustomToken(request: DeleteCustomTokenRequest): Promise<DeleteCustomTokenResponse> {
    const data = DeleteCustomTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteCustomToken", data);
    return promise.then((data) => DeleteCustomTokenResponse.decode(new BinaryReader(data)));
  }

  GetCustomTokens(request: GetCustomTokensRequest): Promise<GetCustomTokensResponse> {
    const data = GetCustomTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCustomTokens", data);
    return promise.then((data) => GetCustomTokensResponse.decode(new BinaryReader(data)));
  }

  GetCustomToken(request: GetCustomTokenRequest): Promise<GetCustomTokenResponse> {
    const data = GetCustomTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCustomToken", data);
    return promise.then((data) => GetCustomTokenResponse.decode(new BinaryReader(data)));
  }
}

export interface DarklakeIntegrationsService {
  Quote(request: QuoteRequest): Promise<QuoteResponse>;
  CreateUnsignedTransaction(request: CreateUnsignedTransactionRequest): Promise<CreateUnsignedTransactionResponse>;
  SendSignedTransaction(request: SendSignedTransactionRequest): Promise<SendSignedTransactionResponse>;
  CheckTradeStatus(request: CheckTradeStatusRequest): Promise<CheckTradeStatusResponse>;
  GetTradesListByUser(request: GetTradesListByUserRequest): Promise<GetTradesListByUserResponse>;
}

export const DarklakeIntegrationsServiceServiceName = "darklake.v1.DarklakeIntegrationsService";
export class DarklakeIntegrationsServiceClientImpl implements DarklakeIntegrationsService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DarklakeIntegrationsServiceServiceName;
    this.rpc = rpc;
    this.Quote = this.Quote.bind(this);
    this.CreateUnsignedTransaction = this.CreateUnsignedTransaction.bind(this);
    this.SendSignedTransaction = this.SendSignedTransaction.bind(this);
    this.CheckTradeStatus = this.CheckTradeStatus.bind(this);
    this.GetTradesListByUser = this.GetTradesListByUser.bind(this);
  }
  Quote(request: QuoteRequest): Promise<QuoteResponse> {
    const data = QuoteRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Quote", data);
    return promise.then((data) => QuoteResponse.decode(new BinaryReader(data)));
  }

  CreateUnsignedTransaction(request: CreateUnsignedTransactionRequest): Promise<CreateUnsignedTransactionResponse> {
    const data = CreateUnsignedTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUnsignedTransaction", data);
    return promise.then((data) => CreateUnsignedTransactionResponse.decode(new BinaryReader(data)));
  }

  SendSignedTransaction(request: SendSignedTransactionRequest): Promise<SendSignedTransactionResponse> {
    const data = SendSignedTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendSignedTransaction", data);
    return promise.then((data) => SendSignedTransactionResponse.decode(new BinaryReader(data)));
  }

  CheckTradeStatus(request: CheckTradeStatusRequest): Promise<CheckTradeStatusResponse> {
    const data = CheckTradeStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckTradeStatus", data);
    return promise.then((data) => CheckTradeStatusResponse.decode(new BinaryReader(data)));
  }

  GetTradesListByUser(request: GetTradesListByUserRequest): Promise<GetTradesListByUserResponse> {
    const data = GetTradesListByUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTradesListByUser", data);
    return promise.then((data) => GetTradesListByUserResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
