# Architecture Guidance for DEX Web

> **Generated**: 2025-10-08  
> **Purpose**: Answer architectural questions about form management, state handling, hook composition, package organization, and more.

---

## Table of Contents

1. [Form Management Strategy](#1-form-management-strategy)
2. [State Management Philosophy](#2-state-management-philosophy)
3. [Hook Composition Strategy](#3-hook-composition-strategy)
4. [Package Organization](#4-package-organization)
5. [Tooling Decisions](#5-tooling-decisions)
6. [Validation & Error Handling](#6-validation--error-handling)
7. [Data Flow](#7-data-flow)
8. [Testing Strategy](#8-testing-strategy)
9. [Migration Strategy](#9-migration-strategy)
10. [Critical Quick Start Answers](#10-critical-quick-start-answers)

---

## 1. Form Management Strategy

### Should we use TanStack Form for all forms?

**‚úÖ YES** - TanStack Form is the standard across the codebase.

**Evidence**:
- Currently used in liquidity forms (`useLiquidityFormState.ts`)
- Creates form hook contexts via `createFormHook` and `createFormHookContexts`
- Integrates well with TanStack Query for server state

**Decision**: Continue using TanStack Form for all forms. No migration planned to other form libraries.

---

### useLiquidityForm vs useLiquidityFormState - Which to use?

**‚úÖ USE `useLiquidityFormState`** - This is the current/canonical implementation.

**Evidence**:
- `useLiquidityFormState` is used in `useLiquidityFormLogic` (line 89 of `useLiquidityFormLogic.ts`)
- `useLiquidityForm` is an older implementation with duplicated validation logic
- The new implementation properly types the form values and follows better patterns

**Migration Path**:
```typescript
// ‚ùå OLD (don't use)
import { useLiquidityForm } from './_hooks/useLiquidityForm';

// ‚úÖ NEW (use this)
import { useLiquidityFormState } from './_hooks/useLiquidityFormState';
```

**Action**: 
- Mark `useLiquidityForm.ts` as deprecated with JSDoc comment
- Eventually remove it after confirming no usage
- Keep `useLiquidityFormState` as the single source of truth

---

### Should form contexts be globally accessible or scoped per form instance?

**‚úÖ SCOPED PER FORM** - Export contexts from the hook file, not globally.

**Current Pattern** (from `useLiquidityFormState.ts`):
```typescript
const { fieldContext, formContext } = createFormHookContexts();

const { useAppForm } = createFormHook({
  fieldComponents: { SwapFormFieldset: FormFieldset },
  fieldContext,
  formComponents: {},
  formContext,
});
```

**Why**: Allows multiple instances of the same form type without context collisions.

---

## 2. State Management Philosophy

### Relationship between XState, TanStack Query, TanStack Form, and React hooks

**‚úÖ "CONDUCTOR PATTERN"** - Established in `useLiquidityFormLogic.ts` (lines 18-23):

```typescript
/**
 * Conductor pattern: orchestrates multiple hooks as siblings and wires them together explicitly.
 * - Query hooks own server state
 * - Form hook owns field state
 * - Machine hook owns workflow state
 * This hook mediates between them without creating nested dependencies.
 */
```

**Ownership Model**:

| State Type | Owner | Examples |
|------------|-------|----------|
| **Server State** | TanStack Query | Pool data, token accounts, token metadata |
| **Form State** | TanStack Form | Input values, validation errors, touched fields |
| **Workflow State** | XState Machine | Transaction flow (ready ‚Üí submitting ‚Üí success/error) |
| **UI State** | React hooks (useState) | Slippage settings, modal open/close, UI toggles |

**Example from `useLiquidityFormLogic.ts`**:
```typescript
// 1. Query hook: owns pool data
const poolDataResult = useRealtimePoolData({ tokenXMint, tokenYMint });

// 2. Token accounts query: owns token balance data
const tokenAccountsData = useRealtimeTokenAccounts({ ... });

// 3. Machine hook: owns workflow state
const transaction = useLiquidityTransactionCore({ form, submitTransaction });

// 4. Form hook: owns field state
const { form } = useLiquidityFormState({ ... });

// 5. Calculations hook: derives values from pool data
const { debouncedCalculateTokenAmounts } = useLiquidityAmountDebouncer(...);
```

---

### When to use state machine vs React Query's isLoading/isError/isSuccess?

**Clear Separation**:

**Use React Query states** for:
- ‚úÖ Data fetching status (loading pool reserves, fetching token metadata)
- ‚úÖ Data mutation status (when mutation hasn't entered transaction flow)
- ‚úÖ Cache invalidation and refetching

**Use XState machine** for:
- ‚úÖ Multi-step transaction workflows (signing ‚Üí submitting ‚Üí confirming)
- ‚úÖ Complex state transitions with business logic
- ‚úÖ Error recovery flows (retry logic)
- ‚úÖ UI state that depends on transaction lifecycle

**Example from `liquidityMachine.ts`**:
```typescript
states: {
  ready: { /* idle, calculating */ },
  submitting: { /* invoking transaction */ },
  signing: { /* awaiting wallet signature */ },
  success: { /* transaction confirmed */ },
  error: { /* with retry logic */ }
}
```

**Never**: Don't duplicate states. If React Query says `isLoading`, don't also track it in XState context.

---

### Is the "conductor pattern" the preferred architecture?

**‚úÖ YES** - This is the established pattern for complex features.

**Benefits**:
1. **No nested dependencies**: Hooks are siblings, not parent-child
2. **Clear ownership**: Each hook owns one type of state
3. **Easy testing**: Can mock individual hooks independently
4. **Better performance**: No unnecessary re-renders from prop drilling

**When to Use**:
- ‚úÖ Features with 3+ hooks interacting
- ‚úÖ Complex flows with server state + form state + workflow state
- ‚úÖ Transaction features (swap, liquidity, staking)

**When NOT to Use**:
- ‚ùå Simple forms with only local state
- ‚ùå Read-only data display components

---

## 3. Hook Composition Strategy

### Current Hook Count: Is 9+ hooks intentional or fragmented?

**‚úÖ INTENTIONAL SEPARATION** - Each hook has a clear, single responsibility.

**Liquidity Hooks Breakdown**:

| Hook | Responsibility | Lines of Code |
|------|---------------|---------------|
| `useLiquidityFormLogic` | üéØ **Conductor** - Orchestrates all hooks | ~120 |
| `useLiquidityFormState` | Form state management | ~87 |
| `useLiquidityTransaction` | Transaction submission logic | ~320 |
| `useLiquidityTransactionCore` | XState machine wrapper | ~44 |
| `useLiquidityTransactionQueries` | Query mutations + invalidation | ~40 |
| `useLiquidityCalculations` | Server-side calculation API calls | ~114 |
| `useLiquidityAmountDebouncer` | Debounced local calculations | ~50 |
| `useLiquidityCalculationWorker` | Web worker for heavy calculations | ~209 |
| `useLiquidityValidation` | Reusable validation logic | ~20 |
| `useOptimisticUpdate` | Optimistic UI updates | ~30 |

**Verdict**: This is good separation of concerns, not fragmentation.

---

### Preferred granularity for hooks?

**‚úÖ SINGLE RESPONSIBILITY PRINCIPLE** - Small, focused hooks.

**Guidelines**:

**Good Hook Size**: 20-200 lines
- ‚úÖ Does one thing well
- ‚úÖ Has clear inputs/outputs
- ‚úÖ Can be tested in isolation
- ‚úÖ Can be reused across features

**Anti-patterns**:
- ‚ùå God hooks (500+ lines doing everything)
- ‚ùå Hooks that mix concerns (form + API + validation + analytics)
- ‚ùå Hooks with side effects hidden from callers

**Example of Good Separation**:
```typescript
// ‚úÖ GOOD: Separate concerns
const form = useLiquidityFormState({ ... });
const transaction = useLiquidityTransaction({ ... });
const calculations = useLiquidityCalculations();

// ‚ùå BAD: One hook does everything
const everything = useLiquidityEverything(); // 1000+ lines
```

---

### Should hooks that always work together be merged?

**‚ö†Ô∏è DEPENDS** - Use the conductor pattern for coupling, not merging.

**Keep Separate**:
- ‚úÖ If they can be tested independently
- ‚úÖ If they have different lifetimes
- ‚úÖ If they might be reused separately

**Merge**:
- ‚úÖ If they're truly inseparable
- ‚úÖ If splitting creates unnecessary complexity
- ‚úÖ If they always share the same dependencies

**Example**: 
- `useLiquidityTransactionCore` + `useLiquidityTransaction` are separate because:
  - Core handles XState machine (reusable)
  - Transaction handles Solana-specific logic (feature-specific)

---

## 4. Package Organization

### Shared Utils Location Strategy

**Decision Tree**:

```
Is it used by 2+ features?
‚îú‚îÄ YES ‚Üí libs/utils/src/
‚îÇ   ‚îú‚îÄ Is it domain-specific (liquidity/swap/pools)?
‚îÇ   ‚îÇ   ‚îî‚îÄ YES ‚Üí libs/utils/src/{domain}/
‚îÇ   ‚îÇ   ‚îî‚îÄ NO ‚Üí libs/utils/src/common/
‚îÇ   ‚îî‚îÄ Is it blockchain-specific?
‚îÇ       ‚îî‚îÄ YES ‚Üí libs/utils/src/blockchain/
‚îî‚îÄ NO ‚Üí apps/web/src/app/[lang]/{feature}/_utils/
```

**Examples from Codebase**:

| Utility | Current Location | Correct? | Reason |
|---------|-----------------|----------|---------|
| `validateHasSufficientBalance` | ‚úÖ `libs/utils/src/common/balanceValidation.ts` | ‚úÖ YES | Used by swap + liquidity + staking |
| `calculateLpTokensToMint` | ‚úÖ `libs/utils/src/liquidity/liquidityMath.ts` | ‚úÖ YES | Liquidity-specific, shared across web + backend |
| `calculateLpTokenAmount` | ‚ö†Ô∏è `apps/web/.../calculateLpTokens.ts` | ‚ö†Ô∏è WRAPPER | Thin wrapper around shared util |
| `getLiquidityFormButtonMessage` | ‚úÖ `apps/web/.../liquidity/_utils/` | ‚úÖ YES | Liquidity UI-specific, not reusable |

---

### validateHasSufficientBalance - Should it move?

**‚úÖ ALREADY IN CORRECT LOCATION** - `libs/utils/src/common/balanceValidation.ts`

**Evidence**:
```typescript
// Exported from libs/utils/src/index.ts (line 26-29)
export {
  checkInsufficientBalance,
  type TokenAccount,
  validateHasSufficientBalance,
} from "./common/balanceValidation";
```

**Used by**: Forms across swap, liquidity, and potentially staking features.

**No action needed** - It's already shared correctly.

---

### Calculation Logic Placement

**‚úÖ CURRENT STRUCTURE IS CORRECT**:

```
libs/utils/src/liquidity/liquidityMath.ts
  ‚Üì (Decimal.js, matches SDK)
  ‚îú‚îÄ calculateLpTokensToMint()
  ‚îú‚îÄ calculateTokensFromLpBurn()
  ‚îú‚îÄ calculateTokenAmountForRatio()
  ‚îî‚îÄ toRawUnitsBigint()

apps/web/.../liquidity/_utils/calculateLpTokens.ts
  ‚Üì (Thin wrapper for web app)
  ‚îî‚îÄ calculateLpTokenAmount() ‚Üí calls calculateLpTokensToMint()

apps/web/.../liquidity/_utils/liquidityCalculations.ts
  ‚Üì (DEPRECATED - marked with @deprecated)
  ‚îî‚îÄ calculateLpTokensFromDeposit() ‚Üí OLD, uses basic JS math
```

**Pattern**:
1. **Core math** lives in `libs/utils/src/liquidity/` (Decimal.js, matches SDK)
2. **Thin adapters** in `apps/web` for UI-specific concerns (formatting, error handling)
3. **Deprecated code** marked with JSDoc, removed in next cleanup

---

### Migration Strategy: Old Calculations ‚Üí New

**‚úÖ IN PROGRESS** - New code exists, old code marked deprecated.

**Status**:
- ‚úÖ New `liquidityMath.ts` created using Decimal.js (matches SDK)
- ‚úÖ Old `liquidityCalculations.ts` marked `@deprecated` (line 32-35)
- ‚è≥ Usage sites need to be migrated
- ‚è≥ Old code removal after migration

**Migration Checklist**:
```typescript
// 1. Find all usage of deprecated functions
grep -r "calculateLpTokensFromDeposit" apps/

// 2. Replace with new implementation
- import { calculateLpTokensFromDeposit } from './_utils/liquidityCalculations';
+ import { calculateLpTokenAmount } from './_utils/calculateLpTokens';

// 3. Update function calls (signature changed)
- const lpTokens = calculateLpTokensFromDeposit({ tokenAAmount, tokenBAmount, poolReserves });
+ const lpTokens = calculateLpTokenAmount(parseFloat(tokenAAmount), parseFloat(tokenBAmount), poolReserves);

// 4. Convert Decimal ‚Üí number if needed
+ const lpTokensNumber = Number(lpTokens.toFixed(9));

// 5. After all migrations, delete liquidityCalculations.ts
```

---

## 5. Tooling Decisions

### BigNumber.js vs Decimal.js - Should we standardize?

**‚ö†Ô∏è DUAL LIBRARY STRATEGY** - Both serve different purposes.

**Current Usage**:

| Library | Purpose | Usage | Location |
|---------|---------|-------|----------|
| **Decimal.js** | ‚úÖ **Precision calculations** | LP token math, pool reserves | `libs/utils/src/liquidity/` |
| **BigNumber.js** | ‚úÖ **Validation & comparison** | Form validation, balance checks | `libs/utils/src/common/` |

**Evidence**:
```typescript
// Decimal.js - for precise calculations (liquidityMath.ts, line 9-12)
Decimal.set({
  precision: 40, // Higher precision for intermediate calculations
  rounding: Decimal.ROUND_DOWN,
});

// BigNumber.js - for validation (amountUtils.ts, line 7-8)
export const parseAmountBigNumber = (value: string): BigNumber => {
  return BigNumber(value.replace(/,/g, ""));
};
```

**Decision**: Keep both libraries.
- **Decimal.js**: Matches SDK, used for math that must be exact
- **BigNumber.js**: Lightweight, used for form validation where performance matters

**Migration**: NO migration needed. This is intentional.

---

### Transaction Signing Pattern

**‚úÖ FEATURE-SPECIFIC WITH COMPOSITION** - Current pattern is correct.

**Current Pattern** (`requestLiquidityTransactionSigning.ts`):
```typescript
export async function requestLiquidityTransactionSigning({
  unsignedTransaction,
  signTransaction,
  publicKey,
  tokenXMint,
  tokenYMint,
  trackingId,
  onSuccess,
  setLiquidityStep,
}: RequestLiquidityTransactionSigningParams) {
  // Feature-specific transaction signing logic
  // Includes: tracking, error handling, confirmation polling
}
```

**Why Feature-Specific**:
1. Each feature has different tracking needs
2. Different success callbacks (invalidate different queries)
3. Different error messages/toasts
4. Different state machine events

**Shared Parts** (should be in `libs/utils/src/blockchain/`):
- ‚úÖ Transaction serialization
- ‚úÖ Solana RPC calls
- ‚úÖ Signature verification
- ‚úÖ Error parsing

**Location**: 
- Feature-specific: `apps/web/.../liquidity/_utils/requestLiquidityTransactionSigning.ts`
- Shared utilities: `libs/utils/src/blockchain/`

---

### Web Worker Usage

**‚ö†Ô∏è CURRENTLY UNUSED** - Worker exists but not actively used.

**Evidence**:
```bash
$ grep -r "useLiquidityCalculationWorker" apps/
# No results - the hook exists but isn't imported anywhere
```

**Decision**: **REMOVE IT** unless you find it's actually needed.

**Why**:
- Current calculations are fast enough (simple ratio math)
- Network latency is the bottleneck, not CPU
- Adds complexity without measurable benefit

**When to Use Workers**:
- ‚úÖ Heavy calculations (>50ms blocking time)
- ‚úÖ Data transformation of large datasets (>10MB)
- ‚úÖ Cryptographic operations

**Liquidity calculations are ~0.1ms**, so workers are overkill.

**Action**: Delete `liquidityCalculationWorker.ts` and `useLiquidityCalculationWorker.ts` in next cleanup.

---

## 6. Validation & Error Handling

### Validation Strategy

**‚úÖ LAYERED VALIDATION** - Multiple layers for different purposes.

**Current Pattern**:

```typescript
// Layer 1: Zod Schema (type + structure validation)
const liquidityFormSchema = z.object({
  tokenAAmount: z.string(),
  tokenBAmount: z.string(),
  initialPrice: z.string(),
});

// Layer 2: TanStack Form Validators (onChange, onBlur, onDynamic)
validators: {
  onChange: liquidityFormSchema, // Type validation
  onDynamic: ({ value }) => {    // Business logic validation
    // Check balance, pool existence, etc.
  }
}

// Layer 3: Separate Validator Functions (reusable)
validateHasSufficientBalance({ amount, tokenAccount });
```

**When to Use Each**:

| Layer | When | Example |
|-------|------|---------|
| **Zod** | Type/format validation | Is it a string? Is it a number format? |
| **onChange** | Real-time type checking | Run Zod schema on every change |
| **onBlur** | Expensive validation | Check balance after user leaves field |
| **onDynamic** | Conditional validation | Validate only if certain fields are filled |
| **Separate Function** | Reusable across features | `validateHasSufficientBalance` used in swap + liquidity |

**Decision**: Keep all three layers. Each serves a purpose.

---

### onChange vs onBlur vs onDynamic

**Guidelines**:

| Validator | Use Case | Performance | User Experience |
|-----------|----------|-------------|-----------------|
| **onChange** | Type validation (Zod) | ‚ö° Fast | Immediate feedback |
| **onBlur** | Expensive checks (API calls) | üê¢ Slow | Don't annoy user while typing |
| **onDynamic** | Conditional validation | ‚ö° Fast | Only when needed |

**Example from `useLiquidityFormState.ts` (lines 58-83)**:
```typescript
validators: {
  onChange: liquidityFormSchema, // ‚ö° Fast Zod check
  onDynamic: ({ value }) => {     // ‚ö° Fast balance check (only if amount > 0)
    if (value.tokenAAmount && parseAmountBigNumber(value.tokenAAmount).gt(0)) {
      // Check balance
    }
  }
}
```

**No onBlur** because balance checks are fast (local, no API call).

---

### Error Handling Pattern

**‚úÖ TIERED ERROR HANDLING** - Different strategies for different error types.

**Current Pattern**:

```typescript
// 1. Toast Notifications (user-facing)
showErrorToast({ message: "Insufficient balance" });
showInfoToast({ message: "Transaction pending" });

// 2. Console Errors (developer-facing)
console.error("Submit transaction failed:", error);

// 3. State Machine Error States (workflow)
send({ type: "ERROR", error: errorMessage });

// 4. Try-Catch Blocks (error boundaries)
try {
  await submitTransaction();
} catch (error) {
  handleTransactionError(error);
}
```

**Decision Tree**:

```
Error Type?
‚îú‚îÄ User needs to know ‚Üí Toast + Machine state
‚îú‚îÄ Developer debugging ‚Üí console.error
‚îú‚îÄ Recoverable ‚Üí Machine state with RETRY event
‚îî‚îÄ Unrecoverable ‚Üí Error boundary
```

**Examples from Code**:

| Error Type | Handler | Location |
|------------|---------|----------|
| Insufficient balance | ‚úÖ Inline form error | Form validator |
| Network error | ‚úÖ Toast + retry | Machine error state |
| Unknown error | ‚úÖ Toast + console | Error boundary |
| Validation error | ‚úÖ Inline form error | Form validator |

---

### Should errors always go through state machine?

**‚ö†Ô∏è NO** - Only workflow errors.

**Through Machine**:
- ‚úÖ Transaction submission failures
- ‚úÖ Signing errors
- ‚úÖ Network timeouts
- ‚úÖ Anything that can be retried

**Outside Machine**:
- ‚úÖ Form validation errors (handled by TanStack Form)
- ‚úÖ Data fetching errors (handled by TanStack Query)
- ‚úÖ UI errors (handled by error boundaries)

---

## 7. Data Flow

### Token Account Data

**‚ö†Ô∏è MULTIPLE FETCHES FOR PERFORMANCE** - Not duplication.

**Current Pattern**:
```typescript
// Feature-level fetch (with feature-specific params)
const tokenAccountsData = useRealtimeTokenAccounts({
  publicKey,
  tokenAAddress,
  tokenBAddress,
  hasRecentTransaction, // Feature-specific param
});
```

**Why Multiple Fetches**:
1. **React Query handles deduplication** - Same query key = single request
2. **Feature-specific parameters** - Different features need different data
3. **Stale-while-revalidate** - Each feature can have different refetch intervals

**Decision**: Keep current pattern. React Query's caching makes this efficient.

---

### Should useRealtimeTokenAccounts be the only way to access data?

**‚úÖ YES** - Single hook for token account data.

**Pattern**:
```typescript
// ‚úÖ GOOD: Fetch at feature root, pass down
function LiquidityPage() {
  const tokenAccountsData = useRealtimeTokenAccounts(...);
  return <LiquidityForm tokenAccountsData={tokenAccountsData} />;
}

// ‚ùå BAD: Fetch in multiple child components
function TokenInput() {
  const tokenAccountsData = useRealtimeTokenAccounts(...); // Causes waterfall
}
```

**Why**: Avoids request waterfalls, easier to reason about data flow.

---

### Pool Data Flow

**‚úÖ FETCH AT ROOT, PASS DOWN** - No Context needed yet.

**Current Pattern** (from `useLiquidityFormLogic.ts`, lines 44-61):
```typescript
// Fetch at conductor level
const poolDataResult = useRealtimePoolData({ tokenXMint, tokenYMint });

// Stabilize and transform
const poolDetails = useMemo(() => {
  const data = poolDataResult.data;
  return data ? { /* transformed */ } : null;
}, [poolDataResult.data]);

// Return to component
return { poolDetails, ... };
```

**When to Use Context**:
- ‚úÖ If data is needed by 5+ components at different nesting levels
- ‚úÖ If prop drilling becomes unwieldy (>3 levels deep)

**Current verdict**: No Context needed. Prop passing is clean.

---

## 8. Testing Strategy

### Test Coverage Expectations

**‚úÖ MAINTAIN EXISTING COVERAGE** - Don't reduce coverage during refactors.

**Current Coverage** (based on existing tests):
- ‚úÖ Core utilities: Unit tests (e.g., `liquidityCalculations.test.ts`)
- ‚úÖ Hooks: Integration tests (e.g., `useLiquidityForm.test.ts`)
- ‚úÖ Components: Behavioral tests
- ‚úÖ E2E: Critical user flows (Playwright)

**During Refactoring**:
1. ‚úÖ Run existing tests to ensure no regressions
2. ‚úÖ Add tests for new utilities
3. ‚úÖ Update tests for changed APIs
4. ‚úÖ Remove tests for deleted code

---

### Should I add new tests for extracted utilities?

**‚úÖ YES** - New shared utilities need tests.

**Test Pyramid**:

```
        /\
       /  \      E2E (Playwright)
      /    \     - Critical user flows only
     /------\    
    /        \   Integration (Vitest + Testing Library)
   /          \  - Hook behavior, multi-component interactions
  /------------\ 
 /              \ Unit (Vitest)
/________________\ - Pure functions, calculations, transformers
```

**Examples**:

| Code | Test Type | Location |
|------|-----------|----------|
| `calculateLpTokensToMint` | ‚úÖ Unit | `libs/utils/src/liquidity/__tests__/` |
| `validateHasSufficientBalance` | ‚úÖ Unit | `libs/utils/src/common/__tests__/` |
| `useLiquidityFormState` | ‚úÖ Integration | `apps/web/.../liquidity/_hooks/__tests__/` |
| `LiquidityForm` | ‚úÖ Integration + E2E | Both locations |

---

### Testing Philosophy

**‚úÖ PRAGMATIC TESTING** - Test behavior, not implementation.

**Good Tests**:
- ‚úÖ Test public API, not internals
- ‚úÖ Test user-facing behavior
- ‚úÖ Test error conditions
- ‚úÖ Use realistic test data

**Bad Tests**:
- ‚ùå Testing private functions
- ‚ùå Testing implementation details (e.g., specific hook calls)
- ‚ùå Brittle snapshots
- ‚ùå Tests that require mocking everything

---

## 9. Migration Strategy

### Refactoring Approach

**‚úÖ CREATE ALONGSIDE, MIGRATE GRADUALLY** - Safer than in-place changes.

**Process**:

```
Phase 1: Create New (‚úÖ DONE)
  ‚îî‚îÄ libs/utils/src/liquidity/liquidityMath.ts

Phase 2: Mark Old as Deprecated (‚úÖ DONE)
  ‚îî‚îÄ @deprecated JSDoc comments in liquidityCalculations.ts

Phase 3: Migrate Usage Sites (‚è≥ IN PROGRESS)
  ‚îú‚îÄ Update imports
  ‚îú‚îÄ Update function calls
  ‚îî‚îÄ Test each change

Phase 4: Remove Old Code (‚è≥ TODO)
  ‚îî‚îÄ Delete after all migrations complete
```

**Why Not In-Place**:
- ‚úÖ Old code keeps working during migration
- ‚úÖ Easy to revert if issues found
- ‚úÖ Clear before/after in git history

---

### Deprecated calculateLpTokensFromDeposit - Removal Timeline

**‚è≥ GRADUAL MIGRATION** - Remove after all usage sites migrated.

**Steps**:
1. ‚úÖ Mark with `@deprecated` JSDoc (DONE)
2. ‚è≥ Find all usage sites: `grep -r "calculateLpTokensFromDeposit"`
3. ‚è≥ Replace with `calculateLpTokenAmount` from new module
4. ‚è≥ Run tests after each replacement
5. ‚è≥ Delete old file after all migrations

**Timeline**: 1-2 weeks (don't rush, test thoroughly)

---

### Breaking Changes to Internal APIs

**‚úÖ ACCEPTABLE** - Internal APIs can break during refactors.

**Definition of Internal**:
- ‚ùå NOT exported from `libs/*/src/index.ts`
- ‚ùå In `_utils`, `_hooks`, `_components` (underscore prefix)
- ‚ùå Used only within single feature

**Definition of Public**:
- ‚úÖ Exported from library root (`libs/utils/src/index.ts`)
- ‚úÖ Used by 2+ features
- ‚úÖ Part of documented API

**Breaking Internal APIs**:
- ‚úÖ No deprecation needed
- ‚úÖ Update all usage in same commit
- ‚úÖ Run tests to verify

**Breaking Public APIs**:
- ‚ö†Ô∏è Requires deprecation period
- ‚ö†Ô∏è Add new API alongside old
- ‚ö†Ô∏è Update all usages gradually

---

### Backward Compatibility During Refactoring

**‚ö†Ô∏è NOT REQUIRED** - Internal refactors can break compatibility.

**When Backward Compatibility IS Required**:
- ‚úÖ Published npm packages
- ‚úÖ Public APIs documented for external use
- ‚úÖ Shared libraries used by other teams

**When NOT Required**:
- ‚ùå Internal feature code (`apps/web/src/app/`)
- ‚ùå Private utilities (underscore prefix)
- ‚ùå Code only used in one place

**Current Refactor**: No backward compatibility needed. Update all usage sites in same PR.

---

## 10. Critical Quick Start Answers

> **TL;DR**: Start here if you need answers fast.

---

### 1. Form Hooks: Merge or keep separate?

**‚úÖ KEEP SEPARATE** - But deprecate the old one.

**Action**:
- ‚úÖ Use `useLiquidityFormState` going forward
- ‚úÖ Mark `useLiquidityForm` as `@deprecated`
- ‚úÖ Remove `useLiquidityForm` after confirming zero usage

```typescript
// ‚úÖ USE THIS
const { form } = useLiquidityFormState({ ... });

// ‚ùå DON'T USE (deprecated)
const { form } = useLiquidityForm({ ... });
```

---

### 2. Utils Location: Where should shared utilities live?

**Decision Tree**:

```
Used by 2+ features?
‚îú‚îÄ YES ‚Üí libs/utils/src/{domain}/
‚îÇ   ‚îú‚îÄ Domain-specific? ‚Üí libs/utils/src/liquidity/
‚îÇ   ‚îî‚îÄ Generic? ‚Üí libs/utils/src/common/
‚îî‚îÄ NO ‚Üí apps/web/.../feature/_utils/
```

**Examples**:
- ‚úÖ `validateHasSufficientBalance` ‚Üí `libs/utils/src/common/` (shared)
- ‚úÖ `calculateLpTokensToMint` ‚Üí `libs/utils/src/liquidity/` (domain)
- ‚úÖ `getLiquidityFormButtonMessage` ‚Üí `apps/web/.../liquidity/_utils/` (feature-specific)

---

### 3. BigNumber vs Decimal: Standardize on one?

**‚úÖ KEEP BOTH** - They serve different purposes.

| Library | Purpose | Where |
|---------|---------|-------|
| **Decimal.js** | Precision math (LP tokens, reserves) | `libs/utils/src/liquidity/` |
| **BigNumber.js** | Fast validation/comparison | `libs/utils/src/common/` |

**No migration needed** - This is intentional architecture.

---

### 4. Refactoring Style: In-place or alongside?

**‚úÖ NEW CODE ALONGSIDE OLD** - Safer migration.

**Process**:
1. ‚úÖ Create new implementation (‚úÖ DONE: `liquidityMath.ts`)
2. ‚úÖ Mark old as `@deprecated` (‚úÖ DONE)
3. ‚è≥ Migrate usage sites gradually (‚è≥ TODO)
4. ‚è≥ Delete old after all migrations (‚è≥ TODO)

**Why**: Old code keeps working, easy to revert, clear git history.

---

## Appendix: File Structure Reference

```
apps/web/src/app/[lang]/liquidity/
‚îú‚îÄ _components/          # UI components
‚îÇ  ‚îî‚îÄ LiquidityForm.tsx  # Main form component
‚îú‚îÄ _hooks/               # Feature hooks
‚îÇ  ‚îú‚îÄ useLiquidityFormLogic.ts      # üéØ Conductor hook
‚îÇ  ‚îú‚îÄ useLiquidityFormState.ts      # ‚úÖ USE THIS
‚îÇ  ‚îú‚îÄ useLiquidityForm.ts           # ‚ùå DEPRECATED
‚îÇ  ‚îú‚îÄ useLiquidityTransaction.ts    # Transaction submission
‚îÇ  ‚îú‚îÄ useLiquidityTransactionCore.ts # XState wrapper
‚îÇ  ‚îî‚îÄ useLiquidityCalculations.ts   # Server calculations
‚îú‚îÄ _machines/            # XState machines
‚îÇ  ‚îî‚îÄ liquidityMachine.ts           # Workflow state
‚îú‚îÄ _utils/               # Feature-specific utilities
‚îÇ  ‚îú‚îÄ calculateLpTokens.ts          # ‚úÖ Thin wrapper
‚îÇ  ‚îî‚îÄ liquidityCalculations.ts      # ‚ùå DEPRECATED
‚îî‚îÄ _workers/             # Web workers (unused)
   ‚îî‚îÄ liquidityCalculationWorker.ts # ‚ùå DELETE

libs/utils/src/
‚îú‚îÄ common/               # Shared generic utilities
‚îÇ  ‚îú‚îÄ amountUtils.ts                # BigNumber parsing
‚îÇ  ‚îî‚îÄ balanceValidation.ts          # ‚úÖ Shared validation
‚îú‚îÄ liquidity/            # Domain-specific utilities
‚îÇ  ‚îú‚îÄ liquidityMath.ts              # ‚úÖ Decimal.js calculations
‚îÇ  ‚îî‚îÄ transformers.ts               # Data transformers
‚îî‚îÄ index.ts              # Public API exports
```

---

## Final Recommendations

### Immediate Actions (This Week)

1. ‚úÖ Mark `useLiquidityForm.ts` as `@deprecated`
2. ‚úÖ Confirm `useLiquidityCalculationWorker` is unused ‚Üí delete it
3. ‚úÖ Add migration plan for `calculateLpTokensFromDeposit` usage sites

### Short Term (Next 2 Weeks)

1. ‚è≥ Migrate all usage of deprecated calculation functions
2. ‚è≥ Remove deprecated files after migration
3. ‚è≥ Add tests for new `liquidityMath.ts` utilities

### Long Term (Next Month)

1. ‚è≥ Document conductor pattern in architecture docs
2. ‚è≥ Create reusable transaction signing utilities
3. ‚è≥ Evaluate if Context is needed for pool data (only if prop drilling becomes painful)

---

## Questions or Clarifications?

If you have additional questions not covered here:

1. **Check the code**: Search for similar patterns in the codebase
2. **Follow established patterns**: Use conductor pattern for complex features
3. **Test your changes**: Maintain existing test coverage
4. **Ask in PR**: Tag maintainers for architectural decisions

---

**Last Updated**: 2025-10-08  
**Maintained By**: Development Team  
**Related Docs**: `DEVELOPMENT.md`, `README.md`
